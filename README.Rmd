---
output: github_document
---
<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Q7

<!-- badges: start -->
<!-- [![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental) -->
<!-- badges: end -->

`Q7` enables _Compositional Object Oriented Programming_, a fluid, powerful and _postmodern_ paradigm, featuring:

#### Smart Objects
  - functions within an object know:
    - Where am I? What are my neighbors? 
  - extensible 
    - Make variants of an object

#### No Magic
  - Mechanism decomposes into basic R constructs 
    - A _type_ is a function
    - A _feature_ is a function
    - An _instance_ is an environment
  - Same great R syntax & semantics
    - Perform any action on or within an object 
    - Native scoping rules, almost no NSE
  
#### Compositional Manner of Construction
  - ...in contrast to hereditary
  - Freely add, change or delete elements, ad or post hoc
  - Focuses on "has a", rather than than "is a" relationships 
  - Objects can contain other objects
  
#### Unlocked Objects
  - Object instances are unlocked environments
  - Feel free to shoot your feet, if so desired
  - Want safety? Lock'em yerself

## Installation

``` r
# install.packages("devtools")
devtools::install_github("iqis/Q7")
```
## Examples

Let's make a `String` type and re-pack some base R functions into it, giving the object a distinct API; Some users may find it familar. 

```{r}
require(Q7)
String <- type(function(string){
  if (length(string) != 1 || !is.character(string)) { 
    # we only want this object to hold a 1-length character vector
    stop("string must be a vector of length 1")
  }
  .my$string <- string
  
  .my$charAt <- function(index){
    unlist(strsplit(.my$string, ""))[index + 1]
  }
  
  .my$concat <- function(str){
    stopifnot(inherits(str, 
                       "String"))
    
    .my$string <- paste0(.my$string, 
                         str$string)
    .my
  }
  
  .my$length <- function(){
    nchar(.my$string)
  }
  
  .my$isEmpty <- function(){
    nchar(.my$string) == 0
  }
  
  .my$matches <- function(pattern){
    .my$string <- grepl(pattern, .my$string)
    .my
  }
  
  .my$replaceFirst <- function(regex, replacement){
    .my$string <- sub(regex, 
                      replacement, 
                      .my$string)
    .my
  }
  
}, s3 = "String")

print.String <- function(String){
  print(String$string)
}
```

We have defined a type named _String_, which will produce instances with a S3 class _String_, as well as a S3 method for `print()`. The `$string` element is the vector that holds the data; All other elements are bound functions (methods) of the object. They understand that they live inside the `String` object. The `print.String()` function lives in the global scope, and simply reaches into the `String` object and print the `$string$` vector.

`.my` object is a special object that refers to the instance itself. Although it can be safely excluded in most cases, with some precaution in place, the use of `.my` is highly recommended to avoid scope leak.



#### Excluding `.my`
Sometimes the repeated reference of `.my` in a type definition is cumbersome. 
```{r}
Yeller <- type(function(words){
  aloud <- function(){paste0(words, "!!!")}
  change_words <- function(new_words){
    words <<- new_words # 
  }
})

greet <- Yeller("Good morning")
greet$aloud()
greet$change_words("Good evening")
greet$aloud()
```


```{r}
motto <- String("Carpe")$concat(String(" "))$concat(String("Diem"))

motto$length()
motto$isEmpty()
motto$charAt(5)
motto$replaceFirst("\\s", "-")$charAt(5)
motto
```



### Interface
- `type()`
  - Defines a _type_. (like _class_)
  - Takes a function as constructor
  - When invoked, the constructor's closure becomes an _instance_, which is an environment
    - Contains every binding inside the closure, except for the arguments
    - The arguments are not accessible outside of the object, making them private
    - Also contains `.my`, which refers to the instance itself
- `feature()`
  - Defines a _feature_
  - Takes any expression
  - Appends the expression to the object
    - Ad hoc: A _feature_ can be implemented on a _type_
    - Post hoc: Can also be implemented on an _instance_ 
- `implement()`
  - Takes
    - object, a _type_ or _instance_
    - any expression (including _features_, but more importantly, any arbitrary expression)
  - Appends the expresseion to the object

`Q7` users may leave behind the grand narrative of classical OOP orthodoxy, and exploit the benefits of objects simply as a unit of code, and as an instrument for namespace resolution.
  
### Versus R6

Q7: Compositonal: I put a collar on my dog.
R6: Hereditary: I made my dog a special kind of dog that has a collar.

Q7: Can add or change features on-the-fly
R6: Must unlock object first; `No apparent equivalent

Q7: Implicit private elements, through constructor arguments
R6: Explicit private elements

Q7: Succinct & sweet: one constructor function defines the whole object
R6: Verbose & bitter: `public`, `private`, `active`, `$new()`, `$clone()`

Q7: Developed by one amateur
R6: Developed by a team of experts

Q7: 


## Some More Examples
Walk through the following comment-free examples and see if you can figure out how `Q7` works.

```{r include=FALSE}
require(Q7)
```

Make a type:
```{r}
TypeOne <- type(function(arg1, arg2){
  
  
})
```
`type()` takes a function, which is used to construct an instance. 

Everything defined within the function's closure becomes elements of the object.
Arguments supplied to the function are accesible to the closure, but not become elements of the object themselves. 
```{r}
type_one <- TypeOne(1, 2)
type_one$...
```

The object can be modified post-hoc. 

```{r}
type_one %>% implement({
  
  
})
```

The features implemented can be packaged with `feature()`. 
```{r}
hasFeatureOne <- feature({
  x <- 1
  y <- function(n){
    x + n
  }
})
```

```{r}
hasFeatureTwo <- feature({
  x <- 2 # Overrides x from hasFeatureOne
  old_y <- y
  y <- function(n){
    old_y(n) + 1
  }
})

```

### Private Elements
```{r}

Counter <- type(function(count = 0){
    add_one <- function(){
      count <<- count + 1
    }
    
    get_count <- function(){
      count
    }
})

```

```{r}
counter <- Counter()
ls(counter)
counter$get_count()
counter$add_one()
counter$add_one()
counter$get_count()
```

### Get Access to Private Environment
```{r}
exposePrivateEnv <- feature({
  .pvt <- parent.env(.my)
})

counter %>% exposePrivateEnv()
counter$.pvt
counter$.pvt$count
```

#### R6 vs Q7
```{r}
R6Example <- R6::R6Class("R6Example", 
                         public = list(
                             var1 = 1, 
                             var2 = 2, 
                             f1 = function(){
                                 self$var3 <- self$var1 + self$var2
                             }, 
                             c = NULL,
                             f2 = function(){
                                 private$var4 <- self$var1 + self$var2
                             }, 
                             f3 = function(){
                                 private$var4
                             }, 
                             initialize = function(){
                                 cat("initializing...")
                             }
                         ), 
                         private = list(
                             var4 = NULL
                         )
)

r6 <- R6Example$new()


require(Q7)
Q7Example <- type(function(var4){
    cat("initializing...")
    var1 <- 1
    var2 <- 2
    var3 <- NULL
    fn1 <- function(){
        var3 <<-  var1 + var2
    }
    fn2 <- function(){
        var4 <<- var1 + var2
    }
    fn3 <- function(){
        var4
    }
})


q7 <- Q7Example()
q7$fn1()
q7$fn2()
q7$fn3()
ls(q7)
```

Why is there no parameterized features?

_feature_ is subordinate to and dependent on _type_. It is encouraged to put all data elements in a _type_ definition, while _feature_ mainly contain just functions. If you feel significant need to parameterize a feature, think whether it's better to create a nested object or to formally extend a type. You can always re-define something in a feature post hoc. 

```{r}
Word <- type(function(word){})
hasRepeat <- feature({
  N_TIMES <- 2
  repeat_word <- function(){
    cat(rep(word, N_TIMES))
  }
})
```

```{r}
apple <- Word("apple") %>% hasRepeat()
apple$repeat_word()
```
```{r}
pear <- Word("pear") %>% 
  hasRepeat() %>% 
  implement({
    N_TIMES <- 5
  })
pear$repeat_word()
```

