---
title: "Introduction to Q7 Type System"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  errors = TRUE
)
```

```{r setup}
library(Q7)
```

# Introduction to Q7 Type System

Q7 is a 

### API
- `type()`
  - Defines a _type_. (like _class_)
  - Takes a function or expression as constructor
  - When invoked, the constructor's closure becomes an _instance_, which is an environment
    - Contains every binding inside the closure, except for the arguments
    - The arguments are not accessible outside of the object, making them private
    - Also contains `.my`, which refers to the instance itself
- `feature()`
  - Defines a _feature_
  - Takes an expression
  - Appends the expression to the object
    - Ad hoc: A _feature_ can be implemented on a _type_
    - Post hoc: Can also be implemented on an _instance_ 
- `implement()`
  - Takes
    - object, a _type_ or _instance_
    - any expression (including _features_, but more importantly, an arbitrary expression)
  - Appends the expresseion to the object

Make a type:
```{r}
TypeOne <- type(function(arg1, arg2){
  add <- function(){
    arg1 + arg2
  }
})
```
`type()` takes a function, which is used to construct an instance. 

Everything defined within the function's closure becomes members of the object.
Arguments supplied to the function are accesible to the closure, but not become members of the object themselves. 
```{r}
type_one <- TypeOne(1, 2)
ls(type_one)
type_one$add()
```


### Reserved Symbols

The following symbols are reserved by the Q7 type system and shall not be re-bound by the user.
 
Binding Modifiers: 

 - `private`: designates a binding in the private environment
 - `public`: designates a binding in the public environment (default)
 - `final`: designates an immutable binding in the public environment
 - `private_final`: designates an immutable binding in the private environment
 - `active`: deisgnates an active binding in the public environment

Environments: 

 - `.my`: an object's public environment
 - `.private`: an object's private environment
 
Functions:

 - `initialize`: one that runs at the instantiation of an object
 - `finalize`: one that runs when an object is garbage collected


### Making Variants of an Object

With Q7, Objects don't inherit; They grow. The benefit is obvious. When you code with inheritance, your mind must navigate from sub- to super-classes from the inside out; Composition, on the otherhand, can be mentally modeled as linear addition to existing code. 

The object can be modified post-hoc after instantiation. 
```{r}
type_one %>% implement({
  substract <- function(){
    arg1 - arg2
  }
})
```

Features can also be packaged with `feature()` for later use. 

```{r}
TypeTwo <- type() # we make an empty type
```

```{r}
hasFeatureOne <- feature({
  x <- 1
  y <- function(n){
    x + n
  }
})
```

```{r}
hasFeatureTwo <- feature({
  x <- 2 # Overrides x from hasFeatureOne
  old_y <- y
  y <- function(n){
    old_y(n) + 1
  }
})
```

```{r}
type_one_with_features <- TypeOne(1,2) %>% 
  hasFeatureOne() %>% 
  hasFeatureTwo()

type_two_with_features <- TypeTwo() %>% 
  hasFeatureOne() %>% 
  hasFeatureTwo()

type_one_with_features$old_y(1)
type_two_with_features$old_y(1)
type_one_with_features$y(1)
type_two_with_features$y(1)
```


#### Private Members
Any domestic founction can read from and write to the private environment. Remember to use the double arrow assignment `<<-` because you want the assignment to pierce the function's closure. Use caution: if the symbol you're assigning to with `<<-` does not exist in either public or private environments, it will end up ouside the object and make a mess.
```{r}
Counter <- type(function(){
  private[count] <- 0
  
  add_one <- function(){
    count <<- count + 1
  }
  
  get_count <- function(){
    count
  }
})
```

```{r}
counter <- Counter()
ls(counter) # count can't be seen from the out side

counter$get_count() # but count can be read by domestic function
counter$add_one() # ... and be written to
counter$add_one()
counter$get_count() # when we read it again the number changes
```

##### Get Access to Private Environment
The private environment (`.private`) is parent of the public environment (`.my`). Parameters supplied to the arguments of the constructor function are implicitly private. When two members in private and public environments have the same name, the one in pulbic will win, and the one in private can only be explicitly qualified with `.private`.

The following code allows direct outside access to the `count` object.
```{r}
exposePrivate <- feature({
  # assigns the .private's reference to itself to .my
  .my$.private <- .private$.private 
  #.private <- .private 
  # also works
})

counter %>% exposePrivate()
# .private reference appears in the object
ls(counter, all.names = TRUE)
counter$.private
counter$.private$count
```





