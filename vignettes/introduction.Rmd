---
title: "Introduction to Q7 Type System"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(Q7)
```


### Make Variants of an Object

Elk will be compared to R6, the premier object system in R; R6 implements classical OOP, which 

With Elk, Objects don't inherit; They grow. 

When you code with inheritance, your mind must navigate from sub- to super-classes from the inside out; Composition, on the otherhand, can be mentally modeled as linear addition to existing code. 


### API
- `type()`
  - Defines a _type_. (like _class_)
  - Takes a function or expression as constructor
  - When invoked, the constructor's closure becomes an _instance_, which is an environment
    - Contains every binding inside the closure, except for the arguments
    - The arguments are not accessible outside of the object, making them private
    - Also contains `.my`, which refers to the instance itself
- `feature()`
  - Defines a _feature_
  - Takes an expression
  - Appends the expression to the object
    - Ad hoc: A _feature_ can be implemented on a _type_
    - Post hoc: Can also be implemented on an _instance_ 
- `implement()`
  - Takes
    - object, a _type_ or _instance_
    - any expression (including _features_, but more importantly, an arbitrary expression)
  - Appends the expresseion to the object






Let's make a `String` type and re-pack some base R functions into it, giving the object a distinct API, which some users may find familar with. 

```{r}
require(Q7)
String <- type(function(string){
  if (length(string) != 1 || !is.character(string)) { 
    # we only want this object to hold a 1-length character vector
    stop("string must be a vector of length 1")
  }
  .my$string <- string
  
  .my$charAt <- function(index){
    unlist(strsplit(.my$string, ""))[index + 1]
  }
  
  .my$concat <- function(str){
    stopifnot(inherits(str, 
                       "String"))
    
    .my$string <- paste0(.my$string, 
                         str$string)
    .my
  }
  
  .my$length <- function(){
    nchar(.my$string)
  }
  
  .my$isEmpty <- function(){
    nchar(.my$string) == 0
  }
  
  .my$matches <- function(pattern){
    .my$string <- grepl(pattern, .my$string)
    .my
  }
  
  .my$replaceFirst <- function(regex, replacement){
    .my$string <- sub(regex, 
                      replacement, 
                      .my$string)
    .my
  }
}, s3 = "String")

print.String <- function(String){
  if (inherits(String, "Q7instance")) {
    print(String$string)
  } else if (inherits(String, "Q7type")) {
    print(String)
  }
}
```

We have defined a type named _String_, which will produce instances with a S3 class _String_, as well as a S3 method for `print()`. The `$string` member is the vector that holds the data; All other members are bound functions (methods) of the object. They understand that they live inside the `String` object. The `print.String()` function lives in the global scope, and simply reaches into the `String` object and print the `$string$` vector.

`.my` object is a special object that refers to the instance itself. Although it can be safely excluded in most cases, with some precaution in place, the use of `.my` is highly recommended to avoid scope leak.

```{r}
motto <- String("Carpe")$concat(String(" "))$concat(String("Diem"))

motto$length()
motto$isEmpty()
motto$charAt(5)
motto$replaceFirst("\\s", "-")$charAt(5)
motto
```



Make a type:
```{r}
TypeOne <- type(function(arg1, arg2){
  
  
})
```
`type()` takes a function, which is used to construct an instance. 

Everything defined within the function's closure becomes members of the object.
Arguments supplied to the function are accesible to the closure, but not become members of the object themselves. 
```{r}
type_one <- TypeOne(1, 2)
type_one$...
```

The object can be modified post-hoc. 

```{r}
type_one %>% implement({
  
  
})
```

The features implemented can be packaged with `feature()`. 
```{r}
hasFeatureOne <- feature({
  x <- 1
  y <- function(n){
    x + n
  }
})
```

```{r}
hasFeatureTwo <- feature({
  x <- 2 # Overrides x from hasFeatureOne
  old_y <- y
  y <- function(n){
    old_y(n) + 1
  }
})

```



#### Private Members
Any member founction can read from and write to the private environment.
```{r}

Counter <- type(function(){
  private[count] <- 1
  
  add_one <- function(){
    count <<- count + 1
  }
  
  get_count <- function(){
    count
  }
})

```

```{r}
counter <- Counter()
ls(counter) # count can't be seen from the out side
```


```{r}
counter$get_count() # but count can be read by member function
counter$add_one() # ... and be written to
counter$add_one()
counter$get_count() # when we read it again the number changes
```


##### Get Access to Private Environment
The private environment (`.private`) is parent of the public environment (`.my`). Parameters supplied to the arguments of the constructor function are implicitly private. 

The following code allows direct outside access to the `count` object.
```{r}
exposePrivate <- feature({
  # assigns the .private's reference to itself to .my
  .my$.private <- .private$.private 
  #.private <- .private 
  # also works
})

counter %>% exposePrivate()
# .private reference appears in the object
counter$.private
counter$.private$count
```

